> 白菜Java自习室 涵盖核心知识

## 1. 分布式事务协议

解决分布式事务，也有相应的规范和协议。分布式事务相关的协议有**2PC**、**3PC**。

### 1.1. （2PC）两阶段提交协议

> 两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。

#### 1.1.1. 准备阶段

协调者询问参与者事务是否执行成功，参与者发回事务执行结果。
![](https://user-gold-cdn.xitu.io/2020/7/11/1733997b9a0167cb?w=780&h=304&f=png&s=121614)

#### 1.1.2. 提交阶段

如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。
需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。
![](https://user-gold-cdn.xitu.io/2020/7/11/1733997d3b6a68bd?w=781&h=322&f=png&s=124031)

#### 1.1.3. 存在的问题

1. 同步阻塞： 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。
2. 单点问题: 协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。
3. 数据不一致: 在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。
4. 太过保守: 任意一个节点失败就会导致整个事务失败，没有完善的容错机制。

### 1.2. （3PC）三阶段提交协议

> 三阶段提交（Three-phase Commit，2PC），与两阶段提交不同的是，三阶段提交有两个改动点。

1. 引入超时机制。同时在协调者和参与者中都引入超时机制。
2. 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。

![](https://user-gold-cdn.xitu.io/2020/7/11/17339a0bdb77cf36?w=611&h=321&f=png&s=25286)

#### 1.2.1. CanCommit阶段

3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。

1. 事务询问 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。
2. 响应反馈 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No。

#### 1.2.2. PreCommit阶段

协调者根据参与者的反应情况来决定是否可以继续事务的PreCommit操作。根据响应情况，有以下两种可能。 假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。

1. 发送预提交请求 协调者向参与者发送PreCommit请求，并进入Prepared阶段。
2. 事务预提交 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。
3. 响应反馈 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。

假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。

1. 发送中断请求 协调者向所有参与者发送abort请求。
2. 中断事务 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。

#### 1.2.3. DoCommit阶段

该阶段进行真正的事务提交，也可以分为以下两种情况。

**执行提交**

1. 发送提交请求： 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。
2. 事务提交： 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。
3. 响应反馈： 事务提交完之后，向协调者发送Ack响应。
4. 完成事务： 协调者接收到所有参与者的ack响应之后，完成事务。

**中断事务**

协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。
1. 发送中断请求： 协调者向所有参与者发送abort请求
2. 事务回滚： 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。
3. 反馈结果： 参与者完成事务回滚之后，向协调者发送ACK消息
4. 中断事务： 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。

## 2. AT 模式

> AT 模式是一种无侵入的分布式事务解决方案。
**阿里Seata框架**，实现了该模式。
在 AT 模式下，用户只需关注自己的“业务 SQL”，用户的 “业务 SQL” 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作。

![](https://user-gold-cdn.xitu.io/2020/7/11/17339a9069d2b1bb?w=1200&h=535&f=webp&s=17868)

AT 模式如何做到对业务的无侵入：

### 2.1. 一阶段

在一阶段，Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，然后执行“业务 SQL”更新业务数据，在业务数据更新之后，再将其保存成“after image”，最后生成行锁。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。

![](https://user-gold-cdn.xitu.io/2020/7/11/17339ab9f46c6c57?w=1200&h=724&f=webp&s=24810)

### 2.2. 二阶段提交

二阶段如果是提交的话，因为“业务 SQL”在一阶段已经提交至数据库， 所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。

![](https://user-gold-cdn.xitu.io/2020/7/11/17339abdfe0f1e80?w=1200&h=538&f=webp&s=12796)

### 2.3. 二阶段回滚

二阶段如果是回滚的话，Seata 就需要回滚一阶段已经执行的“业务 SQL”，还原业务数据。回滚方式便是用“before image”还原业务数据；但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “after image”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理。

![](https://user-gold-cdn.xitu.io/2020/7/11/17339abc6264e707?w=1200&h=839&f=webp&s=29058)

AT 模式的一阶段、二阶段提交和回滚均由 Seata 框架自动生成，用户只需编写“业务 SQL”，便能轻松接入分布式事务，AT 模式是一种对业务无任何侵入的分布式事务解决方案。

## 3. TCC 模式

> TCC 模式需要用户根据自己的业务场景实现 Try、Confirm 和 Cancel 三个操作；事务发起方在一阶段执行 Try 方式，在二阶段提交执行 Confirm 方法，二阶段回滚执行 Cancel 方法。

![](https://user-gold-cdn.xitu.io/2020/7/11/17339ad2c182ae80?w=1200&h=1020&f=webp&s=21192)

TCC 三个方法描述：

**Try**：资源的检测和预留；<br>
**Confirm**：执行的业务操作提交；要求 Try 成功 Confirm 一定要能成功；<br>
**Cancel**：预留资源释放；<br>

### 3.1. 业务模型

用户接入 TCC ，最重要的是考虑如何将自己的业务模型拆成两阶段来实现。

以“扣钱”场景为例，在接入 TCC 前，对 A 账户的扣钱，只需一条更新账户余额的 SQL 便能完成；但是在接入 TCC 之后，用户就需要考虑如何将原来一步就能完成的扣钱操作，拆成两阶段，实现成三个方法，并且保证一阶段 Try 成功的话 二阶段 Confirm 一定能成功。

![](https://user-gold-cdn.xitu.io/2020/7/11/17339b111ca2b33c?w=1200&h=553&f=webp&s=17840)

如上图所示，Try 方法作为一阶段准备方法，需要做资源的检查和预留。在扣钱场景下，Try 要做的事情是就是检查账户余额是否充足，预留转账资金，预留的方式就是冻结 A 账户的 转账资金。Try 方法执行之后，账号 A 余额虽然还是 100，但是其中 30 元已经被冻结了，不能被其他事务使用。

二阶段 Confirm 方法执行真正的扣钱操作。Confirm 会使用 Try 阶段冻结的资金，执行账号扣款。Confirm 方法执行之后，账号 A 在一阶段中冻结的 30 元已经被扣除，账号 A 余额变成 70 元 。

如果二阶段是回滚的话，就需要在 Cancel 方法内释放一阶段 Try 冻结的 30 元，使账号 A 的回到初始状态，100 元全部可用。

用户接入 TCC 模式，最重要的事情就是考虑如何将业务模型拆成 2 阶段，实现成 TCC 的 3 个方法，并且保证 Try 成功 Confirm 一定能成功。相对于 AT 模式，TCC 模式对业务代码有一定的侵入性，但是 TCC 模式无 AT 模式的全局行锁，TCC 性能会比 AT 模式高很多。

### 3.2. 允许空回滚

Cancel 接口设计时需要允许空回滚。在 Try 接口因为丢包时没有收到，事务管理器会触发回滚，这时会触发 Cancel 接口，这时 Cancel 执行时发现没有对应的事务 xid 或主键时，需要返回回滚成功。让事务服务管理器认为已回滚，否则会不断重试，而 Cancel 又没有对应的业务数据可以进行回滚。

![](https://user-gold-cdn.xitu.io/2020/7/11/17339b157f427c34?w=1196&h=530&f=webp&s=25392)

### 3.3. 防悬挂控制

悬挂的意思是：Cancel 比 Try 接口先执行，出现的原因是 Try 由于网络拥堵而超时，事务管理器生成回滚，触发 Cancel 接口，而最终又收到了 Try 接口调用，但是 Cancel 比 Try 先到。按照前面允许空回滚的逻辑，回滚会返回成功，事务管理器认为事务已回滚成功，则此时的 Try 接口不应该执行，否则会产生数据不一致，所以我们在 Cancel 空回滚返回成功之前先记录该条事务 xid 或业务主键，标识这条记录已经回滚过，Try 接口先检查这条事务xid或业务主键如果已经标记为回滚成功过，则不执行 Try 的业务操作。

![](https://user-gold-cdn.xitu.io/2020/7/11/17339b138b9a559f?w=1200&h=503&f=webp&s=24182)

### 3.4. 幂等控制

幂等性的意思是：对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。因为网络抖动或拥堵可能会超时，事务管理器会对资源进行重试操作，所以很可能一个业务操作会被重复调用，为了不因为重复调用而多次占用资源，需要对服务设计时进行幂等控制，通常我们可以用事务 xid 或业务主键判重来控制。

![](https://user-gold-cdn.xitu.io/2020/7/11/17339b18eb7aaf9e?w=1198&h=562&f=webp&s=18592)

## 4. Saga 模式

> Saga 理论出自 Hector & Kenneth 1987发表的论文 Sagas。
saga模式的实现，是长事务解决方案。
Saga 是一种补偿协议，在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。

![](https://user-gold-cdn.xitu.io/2020/7/11/17339b5b18529fa7?w=1200&h=808&f=webp&s=18120)

分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。

Saga 正向服务与补偿服务也需要业务开发者实现。因此是业务入侵的。

Saga 模式下分布式事务通常是由事件驱动的，各个参与者之间是异步执行的，Saga 模式是一种长事务解决方案。

### 4.1. 使用场景

Saga 模式适用于业务流程长且需要保证事务最终一致性的业务系统，Saga 模式一阶段就会提交本地事务，无锁、长流程情况下可以保证性能。

事务参与者可能是其它公司的服务或者是遗留系统的服务，无法进行改造和提供 TCC 要求的接口，可以使用 Saga 模式。

**优势**:
1. 一阶段提交本地数据库事务，无锁，高性能；
2. 参与者可以采用事务驱动异步执行，高吞吐；
3. 补偿服务即正向服务的“反向”，易于理解，易于实现；

**缺点**：Saga 模式由于一阶段已经提交本地数据库事务，且没有进行“预留”动作，所以不能保证隔离性。后续会讲到对于缺乏隔离性的应对措施。

与TCC实践经验相同的是，Saga 模式中，每个事务参与者的冲正、逆向操作，需要支持：

### 4.2. 允许空补偿

允许空补偿：原服务未执行，补偿服务执行了；

![](https://user-gold-cdn.xitu.io/2020/7/11/17339d1af35362f1?w=1168&h=509&f=jpeg&s=89208)

### 4.3. 防悬挂控制

防悬挂控制：补偿服务比原服务先执行，空补偿后要拒绝正向操作；

![](https://user-gold-cdn.xitu.io/2020/7/11/17339d25563bcd1b?w=1157&h=512&f=jpeg&s=97181)

### 4.4. 幂等控制

幂等控制：原服务与补偿服务保证幂等性；

![](https://user-gold-cdn.xitu.io/2020/7/11/17339d216e1069d3?w=1206&h=446&f=jpeg&s=53260)

### 4.5. 自定义事务恢复策略

自定义事务恢复策略：

![](https://user-gold-cdn.xitu.io/2020/7/11/17339d2a074e9a6c?w=1183&h=457&f=jpeg&s=134585)

前面讲到 Saga 模式不保证事务的隔离性，在极端情况下可能出现脏写。比如在分布式事务未提交的情况下，前一个服务的数据被修改了，而后面的服务发生了异常需要进行回滚，可能由于前面服务的数据被修改后无法进行补偿操作。这时的一种处理办法可以是“重试”继续往前完成这个分布式事务。由于整个业务流程是由状态机编排的，即使是事后恢复也可以继续往前重试。所以用户可以根据业务特点配置该流程的事务处理策略是优先“回滚”还是“重试”，当事务超时的时候，Server 端会根据这个策略不断进行重试。

由于 Saga 不保证隔离性，所以我们在业务设计的时候需要做到“宁可长款，不可短款”的原则，长款是指在出现差错的时候站在我方的角度钱多了的情况，钱少了则是短款，因为如果长款可以给客户退款，而短款则可能钱追不回来了，也就是说在业务设计的时候，一定是先扣客户帐再入帐，如果因为隔离性问题造成覆盖更新，也不会出现钱少了的情况。

## 5. XA 模式

> XA是X/Open DTP组织（X/Open DTP group）定义的两阶段提交协议，XA被许多数据库（如Oracle、DB2、SQL Server、MySQL）和中间件等工具(如CICS 和 Tuxedo)本地支持 。
X/Open DTP模型（1994）包括应用程序（AP）、事务管理器（TM）、资源管理器（RM）。
XA接口函数由数据库厂商提供。XA规范的基础是两阶段提交协议2PC。
JTA(Java Transaction API) 是Java实现的XA规范的增强版 接口。

在XA模式下，需要有一个[全局]协调器，每一个数据库事务完成后，进行第一阶段预提交，并通知协调器，把结果给协调器。协调器等所有分支事务操作完成、都预提交后，进行第二步；第二步：协调器通知每个数据库进行逐个commit/rollback。
其中，这个全局协调器就是XA模型中的TM角色，每个分支事务各自的数据库就是RM。

XA模式下的 开源框架有atomikos，其开发公司也有商业版本。

**XA模式缺点**：事务粒度大。高并发下，系统可用性低。因此很少使用。

## 6.（AT、TCC、Saga、XA）模式对比

四种分布式事务模式，分别在不同的时间被提出，每种模式都有它的适用场景：

* **AT 模式**是无侵入的分布式事务解决方案，适用于不希望对业务进行改造的场景，几乎0学习成本。
* **TCC 模式**是高性能分布式事务解决方案，适用于核心系统等对性能有很高要求的场景。
* **Saga 模式**是长事务解决方案，适用于业务流程长且需要保证事务最终一致性的业务系统，Saga 模式一阶段就会提交本地事务，无锁，长流程情况下可以保证性能，多用于渠道层、集成层业务系统。事务参与者可能是其它公司的服务或者是遗留系统的服务，无法进行改造和提供 TCC 要求的接口，也可以使用 Saga 模式。
* **XA模式**是分布式强一致性的解决方案，但性能低而使用较少。
