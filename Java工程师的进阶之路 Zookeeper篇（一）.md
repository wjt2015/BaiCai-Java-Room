> 白菜Java自习室 涵盖核心知识

> [Java工程师的进阶之路 Zookeeper篇（一）](https://juejin.im/post/6870052086239887368)<br>
> [Java工程师的进阶之路 Zookeeper篇（二）](https://juejin.im/post/6870067849021358093)<br>

## 1. Zookeeper 简介

> Zookeeper 分布式服务框架是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。

ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和 命名服务等。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。

## 2. Zookeeper 结构

> Zookeeper=文件系统+通知机制

### 2.1. 文件系统

Zookeeper维护一个类似文件系统的数据结构：

![](//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4d7205f15e441af8e232f46e08693e1~tplv-k3u1fbpfcp-zoom-1.image)

每个子目录项如 NameService 都被称作为 znode，和文件系统一样，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode，唯一的不同在于znode是可以存储数据的。

有四种类型的znode：

1. **PERSISTENT-持久化目录节点**

客户端与Zookeeper断开连接后，该节点依旧存在

2. **PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点**

客户端与Zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号

3. **EPHEMERAL-临时目录节点**

客户端与Zookeeper断开连接后，该节点被删除

4. **EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点**

客户端与Zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号

### 2.2. 通知机制

客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，Zookeeper会通知客户端。 
     
## 3. Zookeeper 功能

### 3.1. 命名服务

在Zookeeper的文件系统里创建一个目录，即有唯一的path。

这个主要是作为分布式命名服务，通过调用Zookeeper的 create node API，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。在我们使用tborg无法确定上游程序的部署机器时即可与下游程序约定好path，通过path即能互相探索发现不见不散了。

### 3.2. 配置管理

程序总是需要配置的，如果程序分散部署在多台机器上，要逐个改变配置就变得困难。

解决方法就是把这些配置全部放到Zookeeper上去，保存在Zookeeper的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到Zookeeper的通知，然后从Zookeeper获取新的配置信息应用到系统中就好。

![](//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f758bcde48124623a34e4f1c6957384b~tplv-k3u1fbpfcp-zoom-1.image)

#### 3.2.1. 发布与订阅

发布与订阅即所谓的配置管理，顾名思义就是将数据发布到zk节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，地址列表等就非常适合使用。

1. 索引信息和集群中机器节点状态存放在zk的一些指定节点，供各个客户端订阅使用。
2. 系统日志（经过处理后的）存储，这些日志通常2-3天后被清除。
3. 应用中用到的一些配置信息集中管理，在应用启动的时候主动来获取一次，并且在节点上注册一个watcher，以后每次配置有更新，实时通知到应用，获取最新配置信息。
4. 业务逻辑中需要用到的一些全局变量，比如一些消息中间件的消息队列通常有个offset，这个offset存放在zk上，这样集群中每个发送者都能知道当前的发送进度。
5. 系统中有些信息需要动态获取，并且还会存在人工手动去修改这个信息。以前通常是暴露出接口，例如JMX接口，有了zk后，只要将这些信息存放到zk节点上即可。

### 3.3. 系统解耦

使用Zookeeper来进行分布式通知和协调能够大大降低系统之间的耦合。

ZooKeeper 中特有watcher注册与异步通知机制，能够很好的实现分布式环境下不同系统之间的通知与协调，实现对数据变更的实时处理。使用方法通常是不同系统都对zk上同一个znode进行注册，监听znode的变化（包括znode本身内容及子节点的），其中一个系统update了znode，那么另一个系统能 够收到通知，并作出相应处理。

1. **心跳检测机制**：检测系统和被检测系统之间并不直接关联起来，而是通过zk上某个节点关联，大大减少系统耦合。
2. **系统调度模式**：某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改了zk上某些节点的状态，而zk就把这些变化通知给他们注册watcher的客户端，即推送系统，于是作出相应的推送任务。
3. **工作汇报模式**：一些类似于任务分发系统，子任务启动后，到zk来注册一个临时节点，并且定时将自己的进度进行汇报（将进度写回这个临时节点），这样任务管理者就能够实时知道任务进度。

### 3.4. 集群管理

所谓集群管理无在乎两点：

* **集群机器监控**
* **选举master**

#### 3.4.1. 集群机器监控

集群机器监控：这通常用于那种对集群中机器状态，机器在线率有较高要求的场景，能够快速对集群中机器变化作出响应。这样的场景中，往往有一个监控系统，实时检测集群机器是否存活。

过去的做法通常是：监控系统通过某种手段（比如ping）定时检测每个机器，或者每个机器自己定时向监控系统汇报“我还活着”。 这种做法可行，但是存在两个比较明显的问题：
1. 集群中机器有变动的时候，牵连修改的东西比较多。
2. 有一定的延时。

利用ZooKeeper有两个特性，就可以实时另一种集群机器存活性监控系统：

1. 客户端在节点 x 上注册一个watcher，那么如果 x 的子节点变化了，会通知该客户端。
2. 创建EPHEMERAL类型的节点，一旦客户端和服务器的会话结束或过期，那么该节点就会消失。

所有机器约定在父目录GroupMembers下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 Zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount又有了。

![](//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04bc4235ad5d44caa4218c5753570642~tplv-k3u1fbpfcp-zoom-1.image)

#### 3.4.2. 选举master

选举master：在分布式环境中，相同的业务应用分布在不同的机器上，有些业务逻辑（例如一些耗时的计算，网络I/O处理），往往只需要让整个集群中的某一台机器进行执行，其余机器可以共享这个结果，这样可以大大减少重复劳动，提高性能，于是这个master选举便是这种场景下的碰到的主要问题。

利用ZooKeeper的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建 /currentMaster 节点，最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很轻易的在分布式环境中进行集群选取了。

### 3.5. 分布式锁

分布式锁，这个主要得益于ZooKeeper为我们保证了数据的强一致性，即用户只要完全相信每时每刻，zk集群中任意节点（一个zk server）上的相同znode的数据是一定是相同的。

锁服务可以分为两类：

* **保持独占**
* **控制时序**

#### 3.5.1. 保持独占

保持独占：就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把zk上的一个znode看作是一把锁，通过create znode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。

#### 3.5.2. 控制时序

控制时序：就是所有视图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里 /distribute_lock 已经预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：CreateMode.EPHEMERAL_SEQUENTIAL来指 定）。zk的父节点（/distribute_lock）维持一份sequence，保证子节点创建的时序性，从而也形成了每个客户端的全局时序。

![](//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ee48d2c048542819a155e5dea480e9b~tplv-k3u1fbpfcp-zoom-1.image)

### 3.6. 队列管理

两种类型的队列：

* **FIFO队列**
* **同步队列** 

#### 3.6.1. FIFO队列

FIFO队列：队列按照 FIFO 方式进行入队和出队操作。和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。

#### 3.6.2. 同步队列

同步队列：当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。

**同步队列其实是在FIFO队列的基础上作了一个增强**。通常可以在 /queue 这个znode下预先建立一个/queue/num 节点，并且赋值为n（或者直接给/queue赋值n），表示队列大小，之后每次有队列成员加入后，就判断下是否已经到达队列大小，决定是否可以开始执行了。

> 这种用法的典型场景是，分布式环境中，一个大任务Task A，需要在很多子任务完成（或条件就绪）情况下才能进行。这个时候，凡是其中一个子任务完成（就绪），那么就去 /taskList 下建立自己的临时时序节点（CreateMode.EPHEMERAL_SEQUENTIAL），当 /taskList 发现自己下面的子节点满足指定个数，就可以进行下一步按序进行处理了。

## 4. Zookeeper 集群

> Zookeeper 作为 Hadoop 项目中的一个子项目，是 Hadoop 集群管理的一个必不可少的模块，它主要用来控制集群中的数据，如它管理 Hadoop 集群中的 NameNode，还有 Hbase 中 Master Election、Server 之间状态同步等。

Zookeeper作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。

### 4.1. 分布式集群

**写主(WriteMaster)**：

对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离；

**写任意(Write Any)**：

对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。

### 4.2. 数据复制的优点

**容错**：
一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作；

**提高系统的扩展能力**：
把负载分布到多个节点上，或者增加节点来提高系统的负载能力；

**提高性能**：
让客户端本地访问就近的节点，提高用户访问速度。

### 4.3. 数据一致性与paxos算法

对Zookeeper来说，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立observer的原因），而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。我们关注的重点还是在如何保证数据在集群所有机器的一致性，这就涉及到**Paxos算法**。

 据说Paxos算法的难理解与算法的知名度一样令人敬仰，所以我们先看如何保持数据的一致性，这里有个原则就是：
 
 > 在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。
 
Paxos算法解决的什么问题呢，解决的就是保证每个节点执行相同的操作序列。好吧，这还不简单，master维护一个全局写队列，所有写操作都必须放入这个队列编号，那么无论我们写多少个节点，只要写操作是按编号来的，就能保证一致性。没错，就是这样，可是如果master挂了呢。
 
**Paxos算法通过投票来对写操作进行全局编号，同一时刻，只有一个写操作被批准，同时并发的写操作要去争取选票，只有获得过半数选票的写操作才会被批准（所以永远只会有一个写操作得到批准），其他的写操作竞争失败只好再发起一轮投票**，就这样，在日复一日年复一年的投票中，所有写操作都被严格编号排序。编号严格递增，当一个节点接受了一个编号为100的写操作，之后又接受到编号为99的写操作（因为网络延迟等很多不可预见原因），它马上能意识到自己数据不一致了，自动停止对外服务并重启同步过程。任何一个节点挂掉都不会影响整个集群的数据一致性（总2n+1台，除非挂掉大于n台）。

> [Java工程师的进阶之路 Zookeeper篇（一）](https://juejin.im/post/6870052086239887368)<br>
> [Java工程师的进阶之路 Zookeeper篇（二）](https://juejin.im/post/6870067849021358093)<br>
